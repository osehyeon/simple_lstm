// This file is computer-generated by onnx2c 
// (TODO: add creating command line here)
// (TODO: print creation date here )

// ONNX model:
// produced by onnx-lstm, version 
// ONNX IR version: 16
// Model documentation: 
/*

*/

#include <float.h>
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#define MAX(X,Y) ( X > Y ? X : Y)
#define MIN(X,Y) ( X < Y ? X : Y)
#define CLIP(X,L) ( MAX(MIN(X,L), -L) )

static const float tensor_W[1][4][1] = 
{
  {
    {-0.17144075036048889160f},
    {-0.30819800496101379395f},
    {0.21058073639869689941f},
    {0.21984648704528808594f}
  }
};
static const float tensor_R[1][4][1] = 
{
  {
    {1.2096968889236450195f},
    {-0.30241891741752624512f},
    {0.22814272344112396240f},
    {0.17871966958045959473f}
  }
};
static const float tensor_B[1][8] = 
{
  {-0.21818579733371734619f, 0.29035821557044982910f, 0.052338920533657073975f, -0.55097019672393798828f, 1.6842622756958007812f, 2.5373005867004394531f, 0.67853581905364990234f, 0.85879528522491455078f}
};
static float tensor_Y_h[1][1][1] = 
{
  {
    {0.0000000000000000000f}
  }
};
static float tensor_Y_c[1][1][1] = 
{
  {
    {0.0000000000000000000f}
  }
};
union tensor_union_0 {
float tensor_Y[10][1][1][1];
};
static union tensor_union_0 tu0;

void forget_gate(float X[1][1][1], float W[1][1][1], float R[1][1][1], float B[1][1], float Y_h[1][1][1], float ft[1][1]){
    
    const int hs = 1;
    const int ds = 1;
    const int bs = 1;

    memset(ft, 0, sizeof(*ft));

    for(int b=0; b<bs; b++)
    for(int h=0; h<hs; h++) {
        ft[b][h]= 0;
        for(int i=0; i<ds; i++) {
            ft[b][h] += X[0][b][i]*W[0][h][i];
        }
        for(int k=0; k<hs; k++) {
            ft[b][h] += Y_h[0][b][k]*R[0][h][k];
        }
        ft[b][h] += B[0][h];
        ft[b][h] = sigmoid(ft[b][h]);
    }
}

void input_gate(float X[1][1][1], float W[1][1][1], float R[1][1][1], float B[1][1], float Y_h[1][1][1], float it[1][1]){
    
    const int hs = 1;
    const int ds = 1;
    const int bs = 1;

    memset(it, 0, sizeof(*it));

    for(int b=0; b<bs; b++)
    for(int h=0; h<hs; h++) {
        it[b][h]= 0;
        for(int i=0; i<ds; i++) {
            it[b][h] += X[0][b][i]*W[0][h][i];
        }
        for(int k=0; k<hs; k++) {
            it[b][h] += Y_h[0][b][k]*R[0][h][k];
        }
        it[b][h] += B[0][h];
        it[b][h] = sigmoid(it[b][h]);
    }
}

void update_gate(float X[1][1][1], float W[1][1][1], float R[1][1][1], float B[1][1], float Y_h[1][1][1], float ct[1][1]){
    
    const int hs = 1;
   const int ds = 1;
   const int bs = 1;

    memset(ct, 0, sizeof(*ct));

    for(int b=0; b<bs; b++)
    for(int h=0; h<hs; h++) {
        ct[b][h]= 0;
        for(int i=0; i<ds; i++) {
            ct[b][h] += X[0][b][i]*W[0][h][i];
        }
        for(int k=0; k<hs; k++) {
            ct[b][h] += Y_h[0][b][k]*R[0][h][k];
        }
        ct[b][h] += B[0][h];
        ct[b][h] = tan_h(ct[b][h]);
    }
}

void output_gate(float X[1][1][1], float W[1][1][1], float R[1][1][1], float B[1][1], float Y_h[1][1][1], float ot[1][1]){
    
    const int hs = 1;
    const int ds = 1;
    const int bs = 1;

    memset(ot, 0, sizeof(*ot));

    for(int b=0; b<bs; b++)
    for(int h=0; h<hs; h++) {
        ot[b][h]= 0;
        for(int i=0; i<ds; i++) {
            ot[b][h] += X[0][b][i]*W[0][h][i];
        }
        for(int k=0; k<hs; k++) {
            ot[b][h] += Y_h[0][b][k]*R[0][h][k];
        }
        ot[b][h] += B[0][h];
        ot[b][h] = sigmoid(ot[b][h]);
    }
}

void cell_state(float ft[1][10], float it[1][1], float ct[1][1], float Y_c[1][1][1]) {
    const int hs = 1;
    const int ds = 1;
    const int bs = 1;

    for( int b=0; b<bs; b++)
    for( int h=0; h<hs; h++) {
        Y_c[0][b][h] = Y_c[0][b][h]*ft[b][h] + it[b][h]*ct[b][h];
    }
}

void output(float ot[1][1],  float Y_h[1][1][1], float Y_c[1][1][1]) {
    const int hs = 1;
    const int ds = 1;
    const int bs = 1;
    
    for( int b=0; b<bs; b++)
      for( int h=0; h<hs; h++) {
         Y_h[0][b][h] = ot[b][h] * tan_h(Y_c[0][b][h]);
      }
}

void entry(const float tensor_X[10][1][1], float tensor_Y_h[1][1][1]) {
/*    
    int hs = 128;
   int ds = 1;
   int bs = 1;
    int iidx = 0;
   int oidx = hs;
   int fidx = 2*hs;
   int cidx = 3*hs;
*/

    float X[1][1][1];

    float Wf[1][1][1];
    float Wi[1][1][1];
    float Wu[1][1][1];
    float Wo[1][1][1];

    memcpy(Wi, &tensor_W[0][0], sizeof(float) * 1);
    memcpy(Wo, &tensor_W[0][1], sizeof(float) * 1);
    memcpy(Wf, &tensor_W[0][2], sizeof(float) * 1);
    memcpy(Wu, &tensor_W[0][3], sizeof(float) * 1);

    float Rf[1][1][1];
    float Ri[1][1][1];
    float Ru[1][1][1];
    float Ro[1][1][1];

    memcpy(Ri, &tensor_R[0][0], sizeof(float) * 1 * 1);
    memcpy(Ro, &tensor_R[0][1], sizeof(float) * 1 * 1);
    memcpy(Rf, &tensor_R[0][2], sizeof(float) * 1 * 1);
    memcpy(Ru, &tensor_R[0][3], sizeof(float) * 1 * 1);

    float Bf[1][1];
    float Bi[1][1];
    float Bu[1][1];
    float Bo[1][1];
    float temp_B[1][1];

    memcpy(Bi, &tensor_B[0][0], sizeof(float) * 1);
    memcpy(temp_B, &tensor_B[0][4], sizeof(float) * 1);
    for(int i = 0; i < 1; i++) {
        Bi[0][i] += temp_B[0][i];
    }
    memcpy(Bo, &tensor_B[0][1], sizeof(float) * 1);
    memcpy(temp_B, &tensor_B[0][5], sizeof(float) * 1);
    for(int i = 0; i < 1; i++) {
        Bo[0][i] += temp_B[0][i];
    }
    memcpy(Bf, &tensor_B[0][2], sizeof(float) * 1);
    memcpy(temp_B, &tensor_B[0][6], sizeof(float) * 1);
    for(int i = 0; i < 1; i++) {
        Bf[0][i] += temp_B[0][i];
    }
    memcpy(Bu, &tensor_B[0][3], sizeof(float) * 1);
    memcpy(temp_B, &tensor_B[0][7], sizeof(float) * 1);
    for(int i = 0; i < 1; i++) {
        Bu[0][i] += temp_B[0][i];
    }
    
    float ft[1][1] = {0};
    float it[1][1] = {0};
    float ct[1][1] = {0};
    float ot[1][1] = {0};

    for( int s=0; s<10; s++) {
        memcpy(X, &tensor_X[s], sizeof(float) * 1 * 1);

        forget_gate(X, Wf, Rf, Bf, tensor_Y_h, ft);
        input_gate(X, Wi, Ri, Bi, tensor_Y_h, it);
        update_gate(X, Wu, Ru, Bu, tensor_Y_h, ct);
        output_gate(X, Wo, Ro, Bo, tensor_Y_h, ot);
        cell_state(ft, it, ct, tensor_Y_c);
        output(ot, tensor_Y_h, tensor_Y_c);
    }
    
}