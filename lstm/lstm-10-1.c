// This file is computer-generated by onnx2c 
// (TODO: add creating command line here)
// (TODO: print creation date here )

// ONNX model:
// produced by onnx-lstm, version 
// ONNX IR version: 16
// Model documentation: 
/*

*/

#include <float.h>
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#define MAX(X,Y) ( X > Y ? X : Y)
#define MIN(X,Y) ( X < Y ? X : Y)
#define CLIP(X,L) ( MAX(MIN(X,L), -L) )

static const float tensor_W[1][4][1] = 
{
  {
    {-0.17144075036048889160f},
    {-0.30819800496101379395f},
    {0.21058073639869689941f},
    {0.21984648704528808594f}
  }
};
static const float tensor_R[1][4][1] = 
{
  {
    {1.2096968889236450195f},
    {-0.30241891741752624512f},
    {0.22814272344112396240f},
    {0.17871966958045959473f}
  }
};
static const float tensor_B[1][8] = 
{
  {-0.21818579733371734619f, 0.29035821557044982910f, 0.052338920533657073975f, -0.55097019672393798828f, 1.6842622756958007812f, 2.5373005867004394531f, 0.67853581905364990234f, 0.85879528522491455078f}
};
static float tensor_Y_h[1][1][1] = 
{
  {
    {0.0000000000000000000f}
  }
};
static float tensor_Y_c[1][1][1] = 
{
  {
    {0.0000000000000000000f}
  }
};
union tensor_union_0 {
float tensor_Y[10][1][1][1];
};
static union tensor_union_0 tu0;




static inline void node_anonymous_LSTM_0( const float X[10][1][1], const float W[1][4][1], const float R[1][4][1], const float B[1][8], float Y[10][1][1][1], float Y_h[1][1][1], float Y_c[1][1][1] )
{
	/* LSTM 
	 * inputs: 
	 *   X = tensor_X
	 *   W = tensor_W
	 *   R = tensor_R
	 *   B = tensor_B
	 *   sequence_lens = 
	 *   initial_h = 
	 *   initial_c = 
	 *   P = 
	 * outputs: 
	 *   Y = tensor_Y
	 *   Y_h = tensor_Y_h
	 *   Y_c = tensor_Y_c
	 * attributes:
	 *   activations: Sigmoid Tanh Tanh 
	 * clip: off
	 * layout: 0
	 * (rest TBD):
	 */
	int hs = 1;
	int ds = 1;
	int bs = 1;
	int iidx = 0;
	int oidx = hs;
	int fidx = 2*hs;
	int cidx = 3*hs;
	int Rb = 4*hs;
	int sequence_lenght = 10;
	/* Forget gate */
	float ft[bs][hs];
	/* Input gate */
	float it[bs][hs];
	/* Cell gate */
	float ct[bs][hs];
	/* Output gate */
	float ot[bs][hs];

	memset(Y_h, 0, sizeof(*Y_h));
	memset(Y_c, 0, sizeof(*Y_c));

	for( int s=0; s<sequence_lenght; s++) {

		/* Forward lane */
		for( int b=0; b<bs; b++)
		for( int h=0; h<hs; h++) {
			ft[b][h]=0;
			it[b][h]=0;
			ct[b][h]=0;
			for( int i=0; i<ds; i++) {
				ft[b][h] += X[s][b][i]*W[0][fidx+h][i];
				it[b][h] += X[s][b][i]*W[0][iidx+h][i];
				ct[b][h] += X[s][b][i]*W[0][cidx+h][i];
			}
			for( int k=0; k<hs; k++) {
				ft[b][h] += Y_h[0][b][k]*R[0][fidx+h][k];
				ct[b][h] += Y_h[0][b][k]*R[0][cidx+h][k];
				it[b][h] += Y_h[0][b][k]*R[0][iidx+h][k];
			}
			ft[b][h] += B[0][fidx+h];
			ft[b][h] += B[0][Rb+fidx+h];
			it[b][h] += B[0][iidx+h];
			it[b][h] += B[0][Rb+iidx+h];
			ct[b][h] += B[0][cidx+h];
			ct[b][h] += B[0][Rb+cidx+h];
			ft[b][h] =1.0f/(1+expf(-ft[b][h]));
			it[b][h] =1.0f/(1+expf(-it[b][h]));
			ct[b][h] =tanh(ct[b][h]);
		}
		for( int b=0; b<bs; b++)
		for( int h=0; h<hs; h++) {
			/* Cell state */
			Y_c[0][b][h] = Y_c[0][b][h]*ft[b][h] + it[b][h]*ct[b][h];
			/* Output gate */
			ot[b][h]=0;
			for( int i=0; i<ds; i++)
				ot[b][h] += X[s][b][i]*W[0][oidx+h][i];
			for( int k=0; k<hs; k++)
				ot[b][h] += Y_h[0][b][k]*R[0][oidx+h][k];
			ot[b][h] += B[0][oidx+h];
			ot[b][h] += B[0][Rb+oidx+h];
			ot[b][h] =1.0f/(1+expf(-ot[b][h]));
		}
		/* Hidden state */
		for( int b=0; b<bs; b++)
		for( int h=0; h<hs; h++) {
			Y_h[0][b][h] = ot[b][h] * tanh(Y_c[0][b][h]);
			Y[s][0][b][h]= Y_h[0][b][h];
		}

	} /* sequences */
}


void entry(const float tensor_X[10][1][1], float tensor_Y_h[1][1][1]) {
	node_anonymous_LSTM_0( tensor_X, tensor_W, tensor_R, tensor_B, tu0.tensor_Y, tensor_Y_h, tensor_Y_c);
}
